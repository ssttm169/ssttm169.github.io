<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[axios请求超时,设置重新请求的完美解决方法]]></title>
      <url>/2017/10/17/vue-axios-timeout-retry-callback/</url>
      <content type="html"><![CDATA[<p>自从使用Vue2之后，就使用官方推荐的axios的插件来调用API，在使用过程中，如果服务器或者网络不稳定掉包了, 你们该如何处理呢? 下面我给你们分享一下我的经历。</p>
<a id="more"></a>
<p><br></p>
<h4 id="具体原因"><a href="#具体原因" class="headerlink" title="具体原因"></a>具体原因</h4><p>最近公司在做一个项目, 服务端数据接口用的是Php输出的API, 有时候在调用的过程中会失败, 在谷歌浏览器里边显示Provisional headers are shown。</p>
<p><img src="/2017/10/17/vue-axios-timeout-retry-callback/1.png" alt=""></p>
<p>按照搜索引擎给出来的解决方案，解决不了我的问题.   </p>
<p><br></p>
<p>最近在研究AOP这个开发编程的概念，axios开发说明里边提到的栏截器(axios.Interceptors)应该是这种机制，降低代码耦合度，提高程序的可重用性，同时提高了开发的效率。</p>
<p><br></p>
<h4 id="带坑的解决方案一"><a href="#带坑的解决方案一" class="headerlink" title="带坑的解决方案一"></a>带坑的解决方案一</h4><p>我的经验有限，觉得唯一能做的，就是axios请求超时之后做一个重新请求。通过研究 axios的使用说明，给它设置一个timeout = 6000</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">axios.defaults.timeout =  <span class="number">6000</span>;</div></pre></td></tr></table></figure>
<p>然后加一个栏截器.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Add a request interceptor</span></div><div class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</div><div class="line">    <span class="comment">// Do something before request is sent</span></div><div class="line">    <span class="keyword">return</span> config;</div><div class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</div><div class="line">    <span class="comment">// Do something with request error</span></div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// Add a response interceptor</span></div><div class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</div><div class="line">    <span class="comment">// Do something with response data</span></div><div class="line">    <span class="keyword">return</span> response;</div><div class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</div><div class="line">    <span class="comment">// Do something with response error</span></div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这个栏截器作用是 如果在请求超时之后，栏截器可以捕抓到信息，然后再进行下一步操作，也就是我想要用 重新请求。</p>
<p><b></b></p>
<p>这里是相关的页面数据请求。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.$axios.get(url, &#123;<span class="attr">params</span>:&#123;<span class="attr">load</span>:<span class="string">'noload'</span>&#125;&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</div><div class="line">	<span class="comment">//dosomething();</span></div><div class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</div><div class="line">	<span class="comment">//超时之后在这里捕抓错误信息.</span></div><div class="line">	<span class="keyword">if</span> (error.response) &#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'error.response'</span>)</div><div class="line">		<span class="built_in">console</span>.log(error.response);</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (error.request) &#123;</div><div class="line">		<span class="built_in">console</span>.log(error.request)</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'error.request'</span>)</div><div class="line">		<span class="keyword">if</span>(error.request.readyState == <span class="number">4</span> &amp;&amp; error.request.status == <span class="number">0</span>)&#123;</div><div class="line">			<span class="comment">//我在这里重新请求</span></div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'Error'</span>, error.message);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">console</span>.log(error.config);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><br></p>
<p>超时之后, 报出 Uncaught (in promise) Error: timeout of  xxx ms exceeded的错误。</p>
<p><img src="/2017/10/17/vue-axios-timeout-retry-callback/2.png" alt=""></p>
<p>在 catch那里，它返回的是error.request错误，所以就在这里做 retry的功能,  经过测试是可以实现重新请求的功功能， 虽然能够实现 超时重新请求的功能，但很麻烦，需要每一个请API的页面里边要设置重新请求。</p>
<p><img src="/2017/10/17/vue-axios-timeout-retry-callback/4.png" alt=""></p>
<p>看上面，我这个项目有几十个.vue 文件，如果每个页面都要去设置超时重新请求的功能，那我要疯掉的. </p>
<p><br></p>
<p>而且这个机制还有一个严重的bug，就是被请求的链接失效或其他原因造成无法正常访问的时候，这个机制失效了，它不会等待我设定的6秒，而且一直在刷，一秒种请求几十次，很容易就把服务器搞垮了，请看下图, 一眨眼的功能，它就请求了146次。</p>
<p><img src="/2017/10/17/vue-axios-timeout-retry-callback/3.png" alt=""></p>
<p><br></p>
<h4 id="带坑的解决方案二"><a href="#带坑的解决方案二" class="headerlink" title="带坑的解决方案二"></a>带坑的解决方案二</h4><p>研究了axios的源代码，超时后,  会在拦截器那里 axios.interceptors.response 捕抓到错误信息,  且 error.code = “ECONNABORTED”，具体链接</p>
<p> <a href="https://github.com/axios/axios/blob/26b06391f831ef98606ec0ed406d2be1742e9850/lib/adapters/xhr.js#L95-L101" target="_blank" rel="external">https://github.com/axios/axios/blob/26b06391f831ef98606ec0ed406d2be1742e9850/lib/adapters/xhr.js#L95-L101</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Handle timeout</span></div><div class="line">request.ontimeout = <span class="function"><span class="keyword">function</span> <span class="title">handleTimeout</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  reject(createError(<span class="string">'timeout of '</span> + config.timeout + <span class="string">'ms exceeded'</span>, config, <span class="string">'ECONNABORTED'</span>,</div><div class="line">    request));</div><div class="line"></div><div class="line">  <span class="comment">// Clean up request</span></div><div class="line">  request = <span class="literal">null</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>所以，我的全局超时重新获取的解决方案这样的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</div><div class="line">....</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> originalRequest = error.config;</div><div class="line">	<span class="keyword">if</span>(error.code == <span class="string">'ECONNABORTED'</span> &amp;&amp; error.message.indexOf(<span class="string">'timeout'</span>)!=<span class="number">-1</span> &amp;&amp; !originalRequest._retry)&#123;</div><div class="line">			originalRequest._retry = <span class="literal">true</span></div><div class="line">			<span class="keyword">return</span> axios.request(originalRequest);</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这个方法，也可以实现得新请求，但有两个问题，1是它只重新请求1次，如果再超时的话，它就停止了，不会再请求。第2个问题是，我在每个有数据请求的页面那里，做了许多操作，比如 this.$axios.get(url).then之后操作。</p>
<p><br></p>
<h4 id="完成的解决方法"><a href="#完成的解决方法" class="headerlink" title="完成的解决方法"></a>完成的解决方法</h4><p>以AOP编程方式，我需要的是一个 超时重新请求的全局功能， 要在axios.Interceptors下功夫，在github的axios的issue找了别人的一些解决方法，终于找到了一个完成解决方案，就是下面这个。</p>
<p><a href="https://github.com/axios/axios/issues/164#issuecomment-327837467" target="_blank" rel="external">https://github.com/axios/axios/issues/164#issuecomment-327837467</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在main.js设置全局的请求次数，请求的间隙</span></div><div class="line">axios.defaults.retry = <span class="number">4</span>;</div><div class="line">axios.defaults.retryDelay = <span class="number">1000</span>;</div><div class="line"></div><div class="line">axios.interceptors.response.use(<span class="literal">undefined</span>, <span class="function"><span class="keyword">function</span> <span class="title">axiosRetryInterceptor</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> config = err.config;</div><div class="line">    <span class="comment">// If config does not exist or the retry option is not set, reject</span></div><div class="line">    <span class="keyword">if</span>(!config || !config.retry) <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err);</div><div class="line">    </div><div class="line">    <span class="comment">// Set the variable for keeping track of the retry count</span></div><div class="line">    config.__retryCount = config.__retryCount || <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// Check if we've maxed out the total number of retries</span></div><div class="line">    <span class="keyword">if</span>(config.__retryCount &gt;= config.retry) &#123;</div><div class="line">        <span class="comment">// Reject with the error</span></div><div class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// Increase the retry count</span></div><div class="line">    config.__retryCount += <span class="number">1</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// Create new promise to handle exponential backoff</span></div><div class="line">    <span class="keyword">var</span> backoff = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            resolve();</div><div class="line">        &#125;, config.retryDelay || <span class="number">1</span>);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="comment">// Return the promise in which recalls axios to retry the request</span></div><div class="line">    <span class="keyword">return</span> backoff.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> axios(config);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>其他的那个几十个.vue页面的 this.$axios的get 和post 的方法根本就不需要去修改它们的代码。</p>
<p>在这个过程中，谢谢jooger给予大量的技术支持，这是他的个人信息 <a href="https://github.com/jo0ger" target="_blank" rel="external">https://github.com/jo0ger</a> ， 谢谢。</p>
<p><br></p>
<p>以下是我做的一个试验。。把axios.defaults.retryDelay = 500, 请求 www.facebook.com</p>
<p><img src="/2017/10/17/vue-axios-timeout-retry-callback/5.png" alt=""></p>
<p>按照惯例，给出源代码，如有更好的建议，请告诉我，谢谢。</p>
<div class="github-widget" data-repo="ssttm169/use-axios-well"></div>]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vue </tag>
            
            <tag> axios </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何快速启动mongodb服务]]></title>
      <url>/2017/10/12/how-to-launch-mongodb-automatically/</url>
      <content type="html"><![CDATA[<p>在桌面上新建一个空的  启动MongoDB.bat , 输入以内命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">D:</div><div class="line">cd D:\mongodb\bin</div><div class="line">net stop MongoDB</div><div class="line">net start MongoDB</div><div class="line">cd D:\Program Files\robo3</div><div class="line">start robo3t.exe</div></pre></td></tr></table></figure>
<a id="more"></a>
<div class="github-widget" data-repo="ssttm169/launch_mongodb"></div>
]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mongodb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2017年9月的总结/收获/感悟]]></title>
      <url>/2017/10/09/what-I-learnt-in-september/</url>
      <content type="html"><![CDATA[<p>9月份的收获满满, 让我总结一下这一个月的感悟和收获。</p>
<p>1.如果你想得到你从未得到的东西，你就要做你从未做过的事情。</p>
<p>2.要迈出自己的舒适区，相信收获和成就会更多更大。要想尽方法去证明自己持有的思维和方法是错误的，要不断地去改进自己做事的方式。</p>
<a id="more"></a>
<p>3.不管做任何的事情，有意识地保护自己，风险最小化，利益最大化，永远把自己处于优势。</p>
<p>4.成为高手的捷径, 发现高手 &gt; 学习高手 &gt; 互动高手 &gt; 最终成为高手。</p>
<p>5.做事有计划，事后有总结，要对结果负责，就算是失败了，也不太自责，要保持积极和乐观的心态，总结到底为什么会失败，下次再努力，计划 &gt; 执行 &gt; 失败 &gt; 总结 &gt; 提升积极性和能力 &gt; 计划…这是一个良性循环。</p>
<p>6.我现在感得骄傲的好习惯，其实很脆弱的，因为我根本就没有从内心去改变自己。唯有由内心驱使的习惯，才是好习惯，这种习惯，是雷打不动的，看来我还是需要继续努力，继续加油。</p>
<p>7.要把仅有的时间和精力，花费在自己的影响圈上面，其他的东西随他们去吧。</p>
<p>8.一切均为概率论, 如何出门不挨车撞? 遵守交通规则，不闯红灯，不抢道，不贪快，晚上出门时不要穿深色的衣服，这样发生车祸的概率是非常少。这种概率论适用任何行业，任何事物..</p>
<p>9.也是概率论, 查理芒格自创的投资方法，类拟于排除法，开始之前，成功投资的概率是12%, 第1步.去掉各种安全隐患(风险) , 提升到40%， 第2步 经过多元思维去分折, 提升到60%,  第3步 耐心等待 80%….。</p>
<p>10.了解到查理芒格是一个非常聪明, 极度自律, 诚实正直, 很有耐心的人, 他的成就归功于他的一生从来都没有停止过自我教育, 他是一个非常值得学习的对象。</p>
<p>11.每天都要争取比昨天聪明一点点，要出色地完成自己手头上的工作，保持这种状态，经过漫长一段时间之后(可能是3年，或5年, 10年)，就能过上完美的人生。</p>
]]></content>
      
        <categories>
            
            <category> 个人成长 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo开启post_asset_folder后, 安装hexo-asset-image,不起作用的问题]]></title>
      <url>/2017/09/29/the-problem-when-use-post-asset-folder/</url>
      <content type="html"><![CDATA[<p>使用Hexo和github搭建博客，真是挺有趣的事情，因为对于我们来说，随便敲几行代码，就可以拥有一个非常漂亮的博客。 但在写作的过程中，使用Typora(一个markdown编辑器)插入图片的时候，非常不顺手。后来了解到用hexo-asset-image可以提升我的写作效率,,所以开始吧。</p>
<a id="more"></a>
<p><br></p>
<h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><p>在nodejs里边安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-asset-image --save</div></pre></td></tr></table></figure>
<div align="center"><br><img src="/2017/09/29/the-problem-when-use-post-asset-folder/1.png" alt="安装hexo-asset-image"><br></div>


<p><br></p>
<p>把在hexo根目下的_config.yml设置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">post_asset_folder: true</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h4><p>安装完了之后，新建一篇名为test-img的文章</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo new [layout] test-img</div></pre></td></tr></table></figure>
<div align="center"><br><br><img src="/2017/09/29/the-problem-when-use-post-asset-folder/2.png" alt=""><br><br></div>



<p>  <br></p>
<p>现在可以看到source/_posts里边，除了有test-img.md，还多一个文件夹 test-img</p>
<div align="center"><br><br><img src="/2017/09/29/the-problem-when-use-post-asset-folder/3.png" alt=""></div>



<p><br></p>
<p>在里边我放一张名为me.jpg的图片, 插入图片的时候，输入  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![](test-img/me.jpg)</div></pre></td></tr></table></figure>
<p>如图所示：</p>
<div align="center"><img src="/2017/09/29/the-problem-when-use-post-asset-folder/4.png" alt=""></div>



<p><br></p>
<h4 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h4><p>当我回到nodejs的时候，发现不对劲~</p>
<div align="center"><img src="/2017/09/29/the-problem-when-use-post-asset-folder/5.png" alt=""></div>



<p><br></p>
<p>然后，我去页面看，图片不显示， chrome-devtools显示，找不到图片。</p>
<div align="center"><img src="/2017/09/29/the-problem-when-use-post-asset-folder/6.png" alt=""></div>



<p><br></p>
<p>当我用hexo g生成文件的时候，发现报错， 如下：</p>
<div align="center"><img src="/2017/09/29/the-problem-when-use-post-asset-folder/7.png" alt=""></div>

<p>FATAL something’s wrong. May be you can find the solution here…..</p>
<p>Error: ENOENT: no such file or directory, open ‘D:\nodejs6.5\hexo_blog\public\20<br>17-09-29-test-img.html\me.jpg’  </p>
<p>仔细一看路径是</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">\public\2017-09-29-test-img.html\me.jpg</div></pre></td></tr></table></figure>
<p><br></p>
<p>在public文件夹里边也找不到2017-09-29-test-img.html文件夹。</p>
<div align="center"><img src="/2017/09/29/the-problem-when-use-post-asset-folder/8.png" alt=""></div>



<p><br></p>
<p>百思不得期解，我了解别人的博客都是的链接都是       域名/年份/月份/文件名  的路径， 比如：<a href="http://www.54tianzhisheng.cn/2017/09/23/Guava-limit/" target="_blank" rel="external">http://www.54tianzhisheng.cn/2017/09/23/Guava-limit/</a></p>
<div align="center"><img src="/2017/09/29/the-problem-when-use-post-asset-folder/9.png" alt=""></div>



<p><br></p>
<p>而且我的路径是 <a href="http://www.itomtan.com/2017-09-27-how-to-use-wechat-debug.html，">http://www.itomtan.com/2017-09-27-how-to-use-wechat-debug.html，</a> 所有的html都是放到</p>
<div align="center"><img src="/2017/09/29/the-problem-when-use-post-asset-folder/10.png" alt=""></div>



<p><br></p>
<h4 id="找到原因"><a href="#找到原因" class="headerlink" title="找到原因"></a>找到原因</h4><p>为了满意的我好奇心~~，最终我找到了原因。原来，之前我把hexo根目下的_config.yml， 把permalink 设置为 year-:month-:day-:title.html，hexo就会在根目下生成html, 而导致 生成 相关的文件夹失效。</p>
<div align="center"><img src="/2017/09/29/the-problem-when-use-post-asset-folder/11.png" alt=""></div>



<p>是 permalink 和 post_asset_folder 这两个参数是相互影响的。</p>
<p><br></p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>把hexo根目下的_config.yml， 把permalink 设置为 :year/:month/:day/:title/</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">permalink: :year/:month/:day/:title/</div></pre></td></tr></table></figure>
<p>好，重新hexo clean &amp;&amp; hexo g , 得到的就是我们要的那种方路径，而且图片显示正常了。</p>
<div align="center"><img src="/2017/09/29/the-problem-when-use-post-asset-folder/12.png" alt=""></div>



<p><br></p>
<p>温馨提示一下：</p>
<p>用Typora插入图片时  输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![](文件名.png)</div></pre></td></tr></table></figure>
<p>的时候，虽然在图片网页上能够正常显示，但是在Typora编辑时无法显示，那如何才能让Typora正常显示呢? 这里分享一个小技巧：</p>
<p>在Typora中, 选择Edit &gt; Image Tools &gt;  Use Image Root Path， 然后选择你要的相关文件夹，选择之后，在md文件头上 会多一个 typora-root-url: xxxx, 好了，现在可以正常显示了。具体操作看下图。</p>
<div align="center"><img src="/2017/09/29/the-problem-when-use-post-asset-folder/13.png" alt=""></div>

<p><br></p>
<div align="center"><img src="/2017/09/29/the-problem-when-use-post-asset-folder/14.png" alt=""></div>

<p><br></p>
<div align="center"><img src="/2017/09/29/the-problem-when-use-post-asset-folder/15.png" alt=""></div>

<p><br></p>
<p>最后，分享一下源代码：</p>
<div class="github-widget" data-repo="ssttm169/hexo_blog"></div>]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[H5,移动端调试神器 微信web开发者工具]]></title>
      <url>/2017/09/27/how-to-use-wechat-debug/</url>
      <content type="html"><![CDATA[<p> 微信整合了社交，支付，自媒体等强大的功能，现在许多H5的网页都是通过微信的浏览的，所以在开发过程，是避免不了出现问题，但是在手机上浏览，我们是无法知道是哪里出错了。对于这个问题， 可以使用微信web开发者工具解决。</p>
<a id="more"></a>
<p>名称为：wechat_web_devtools_0.7.0_x64.exe。</p>
<h4 id="扫码登陆"><a href="#扫码登陆" class="headerlink" title="扫码登陆"></a>扫码登陆</h4><p>打开工具之后, 打开微信，扫码登陆</p>
<div align="center"><br><img src="/2017/09/27/how-to-use-wechat-debug/1.png" alt="扫码登陆"><br></div>


<h4 id="点击移动调试"><a href="#点击移动调试" class="headerlink" title="点击移动调试"></a>点击移动调试</h4><p>登录成功之后，点击移动调试，按照里边说明所示，</p>
<div align="center"><br><img src="/2017/09/27/how-to-use-wechat-debug/2.png" alt="点击移动调试"><br></div>


<h4 id="设置wifi的代理"><a href="#设置wifi的代理" class="headerlink" title="设置wifi的代理"></a>设置wifi的代理</h4><div align="center"><br><img src="/2017/09/27/how-to-use-wechat-debug/3.png" alt="按照里边说明所示"><br></div>


<h4 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h4><p>手机设置成功之后，点击 开始调试</p>
<div align="center"><br><img src="/2017/09/27/how-to-use-wechat-debug/4.png" alt="开始调试"><br></div>



<p><strong>注意，如果系统提示你升级，千万不要升级，新版删除移动调试的功能：</strong></p>
<p>如果你找不到安装文件，我这里提供一下</p>
<div class="github-widget" data-repo="ssttm169/wechat_web_devtools_0.7.0_x64"></div>



]]></content>
      
        <categories>
            
            <category> 工具使用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 微信web开发者工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[做人做事准则]]></title>
      <url>/2017/09/27/how-to-be-a-man/</url>
      <content type="html"><![CDATA[<p>1.不管发生什么事情，都不要乱发脾气，要冷静，想清楚之后，再做决定。<br>2.时间利用最大化，不浪费一分一秒。<br><a id="more"></a><br>3.不管多忙，都要保待良好的阅读习惯，因为这是快速成长的方式之一。<br>4.做事有计划，事后有总结，要对结果负责，否则无法按时完成任务，也不能改进做事的方式，没有收获等于浪费时间，浪费生命。<br>5.积极主动，把被动变成主动，杜绝消极的心态。 就算遇到挫折，也不要灰心，保持积极的心态，总结反思，重新再来。<br>6.有意志地缎练说话的能力，会说话能顶个千万雄师。<br>7.讲诚信，答应人家的事情，要按时按量完成。<br>8.每天都必须有一点点进步，有一点点收获，还记得越努力越幸运的公式吗~？<br>9.以学习的心态去工作，用新的方法解决问题，在工作中学习，在学习中工作。</p>
]]></content>
      
        <categories>
            
            <category> 个人成长 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[设置contentEditable="true"作为文本编辑器，定位光标解决办法]]></title>
      <url>/2017/09/27/hello-world/</url>
      <content type="html"><![CDATA[<p>html部分</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ql-editor ql-blank"</span> <span class="attr">id</span>=<span class="string">"myEditor"</span> <span class="attr">style</span>=<span class="string">"padding:10px;width: 100%;height: 100%;overflow-y: scroll;"</span> <span class="attr">contentEditable</span>=<span class="string">"true"</span> <span class="attr">data-placeholder</span>=<span class="string">"这里输入内容!"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>设置焦点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">setCaretPosition() &#123;</div><div class="line">    <span class="keyword">var</span> sel;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.savedRange != <span class="literal">null</span>) &#123;</div><div class="line"></div><div class="line">        sel = <span class="keyword">this</span>.win.getSelection();</div><div class="line">        <span class="keyword">if</span> (sel.rangeCount &gt; <span class="number">0</span>)</div><div class="line">            sel.removeAllRanges();</div><div class="line">        sel.addRange(<span class="keyword">this</span>.savedRange);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( (sel = <span class="keyword">this</span>.doc.selection) &amp;&amp; sel.type != <span class="string">"Control"</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">this</span>.win.getSelection().addRange(<span class="keyword">this</span>.savedRange);</div><div class="line">    &#125;</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>获取焦点</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">getCaretCharacterOffsetWithin() &#123;</div><div class="line">    <span class="keyword">var</span> caretOffset = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> sel;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.win.getSelection != <span class="string">"undefined"</span>) &#123;</div><div class="line">        sel = <span class="keyword">this</span>.win.getSelection();</div><div class="line">        <span class="keyword">if</span> (sel.rangeCount &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">var</span> range = <span class="keyword">this</span>.win.getSelection().getRangeAt(<span class="number">0</span>);</div><div class="line">            <span class="keyword">var</span> preCaretRange = range.cloneRange();</div><div class="line">            preCaretRange.selectNodeContents(<span class="keyword">this</span>.editor);</div><div class="line">            preCaretRange.setEnd(range.endContainer, range.endOffset);</div><div class="line">            caretOffset = preCaretRange.toString().length;</div><div class="line">            <span class="keyword">this</span>.savedRange = range</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( (sel = <span class="keyword">this</span>.doc.selection) &amp;&amp; sel.type != <span class="string">"Control"</span>) &#123;</div><div class="line">        <span class="keyword">var</span> textRange = sel.createRange();</div><div class="line">        <span class="keyword">var</span> preCaretTextRange = <span class="keyword">this</span>.doc.body.createTextRange();</div><div class="line">        preCaretTextRange.moveToElementText(<span class="keyword">this</span>.editor);</div><div class="line">        preCaretTextRange.setEndPoint(<span class="string">"EndToEnd"</span>, textRange);</div><div class="line">        caretOffset = preCaretTextRange.text.length;</div><div class="line">        <span class="keyword">this</span>.savedRange = textRange</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.caretOffset = caretOffset;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>源代码使用Vue2 + Vux</p>
<p>为了方便测试，源代码调用了Vux的WechatEmotion组件，在编辑器中插件图片。</p>
<p>github源代码的网址如下：</p>
<div class="github-widget" data-repo="ssttm169/tom-editor"></div>


]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 编辑器 </tag>
            
            <tag> Vux </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
